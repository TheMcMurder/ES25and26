---
layout: default
---

# ECMAScript 2025 Highlights

## Key Features Finalized

- JSON imports and import attributes
- Iterator and set helpers
- RegExp modifiers
- Float16Array

---

# JSON Imports and import attributes

## Before

```js
// Had to use fetch + await
const response = await fetch('./config.json');
const config = await response.json();

// Or in Node, hacky require() workarounds
// And bundlers added special config just for JSON imports
```

## After

```js
// Configuration file for your dashboard
import config from './dashboard-config.json' with { type: 'json' };

// Feature flags (often loaded from a service)
import flags from './features.json' with { type: 'json' };
if (flags.newUI) { /* use new UI */ }

// Localization/i18n
import translations from './en-US.json' with { type: 'json' };

```

---

# JSON Imports

- No fetch boilerplate
- Module loader can validate at load time instead of run-time
- Type safety - no JS can be inserted
- CDN safe
- Eliminates build-tool config and fetch wrappers

---

# Import Attributes future proofing

```js
// Future possibilities (not yet in spec, but the syntax handles it):
import wasm from './module.wasm' with { type: 'webassembly' };
import css from './styles.css' with { type: 'css' };
import svg from './icon.svg' with { type: 'svg' };
```

---

# Iterator and Set helpers

## The problem

```js
// Traditional array approach - processes EVERYTHING immediately
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const result = numbers
  .filter(n => n % 2 === 0)    // Creates intermediate array: [2,4,6,8,10]
  .map(n => n * 2)             // Creates another array: [4,8,12,16,20]
  .slice(0, 2);                // Finally: [4, 8]

// Memory issue: With 1 million items, you're creating
// 2-3 million-item arrays in memory, then discarding most of them!
```

- Creates immediate arrays you throw away
- Memory overhead with large datasets
- Processing delay before you get any results
- No way to hanle infinite sequences

---

# Iterator and Set Helpers

## The solution

```js
// ES2025 iterator approach - lazy, memory-efficient
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const result = numbers[Symbol.iterator]()
  .filter(n => n % 2 === 0)    // Doesn't create array
  .map(n => n * 2)              // Still doesn't create array
  .take(2)                       // Stops processing after 2 items!
  .toArray();                    // Finally: [4, 8]

// Same result, but:
// ✅ No intermediate arrays
// ✅ Only processes items you actually need
// ✅ Works with Sets, Maps, and ANY iterable
```

---

# Iterator and Set Helpers

## Infinite Sequences

```js
// Generate infinite sequence of numbers
function* infiniteNumbers() {
  let i = 0;
  while (true) yield i++;
}

// Get first 10 even numbers - stops immediately!
const result = infiniteNumbers()
  .filter(n => n % 2 === 0)
  .take(10)
  .toArray();

console.log(result);
// [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

// Without iterators, this would hang forever!
// Iterators let you express "take the first N that match"

```

- Lazy eval without RxJS or Lodash


---

# Iterator and Set Helpers

## Processing Large data

```js
// Scenario: Filter a list of 10,000 users, get first 2 active ones

// ❌ Old way - processes all 10,000
const activeUsers = allUsers.filter(u => u.active);
const result = activeUsers.slice(0, 2);

// ✅ New way - stops after finding 2
const result = allUsers[Symbol.iterator]()
  .filter(u => u.active)
  .take(2)
  .toArray();

// Real benefit: If user #5 is the 2nd active one,
// you never even look at users #6-#10,000


```

- Useful in APIs, stream processing, and large dataset filtering

---

# Iterator and Set Helpers

## Chaining multiple operations

```js
// CSV processing example
function* readCSVLines(csv) {
  for (const line of csv.split('\n')) {
    yield JSON.parse(line);  // Assume JSONL format
  }
}

// Process: skip header → filter by date → take first 10
const results = readCSVLines(csvData)
  .drop(1)                        // Skip header row
  .filter(row => row.date > '2026-01-01')
  .map(row => ({ name: row.name, value: row.price }))
  .take(10)
  .toArray();

// Performance: Only reads lines up to the 10th matching row,
// never touches the rest of the file!



```

- Never load an entire CSV into memory again

# Iterator and Set Helpers

## Available methods 

```js
.map(fn)        // Transform each value
.filter(fn)     // Keep values where fn returns true
.take(n)        // Stop after n values
.drop(n)        // Skip first n values
.flatMap(fn)    // Map + flatten (useful for AI workflows)
.reduce(fn)     // Aggregate into single value
.find(fn)       // Return first match
.some(fn)       // Returns true if any match (stops early!)
.every(fn)      // Returns true if all match (stops early!)
.toArray()      // Convert to array (now you materialize)
.forEach(fn)    // Execute side effect on each

```

- most return an iterator so you can keep chaining
